# Exam - C

## Importante

### Conselhos Fundamentais

1. **Não cole ou pesquise na internet**: Você está fazendo uma prova.
2. **Estude e revise antes de fazer a prova**: Para não ter que quebrar o conselho acima.
3. **Delimite ou ao menos calcule o tempo investido para realizar o teste**.

---

## Exam00

Aqui eu acho que é importante você estar preparado e confortável. Não pode sair daqui para os próximos módulos sem saber:

- **Navegar e usar o CLI** de maneira útil e prática.
- O **básico da sintaxe em C**: loops e condicionais.
- A parte inicial de **ponteiros**.
- Usar o comando `man`.
- Como funciona a tabela **ASCII**.

### Conselhos

Do ponto de vista de algoritmo, o principal que, ao meu ver, você precisa sair daqui dominando é a **reversão de string**. Aprenda, decore, dê seus jeitos. Eu recomendo o clássico *two pointers*.

Na parte de ponteiros, você tem 2 abordagens diferentes: uma com índice, que é mais intuitiva e amplamente usada em outras linguagens, e a outra seria com aritmética de ponteiros. Inicialmente, comecei estudando por índice, mas me forcei a treinar e aplicar mais a parte de aritmética de ponteiros justamente para me expor mais ao assunto e tentar cada vez mais aprender sobre. Penso que fora do C vamos ter muitas oportunidades em várias stacks para trabalhar com índices, e no fim a lógica não é tão diferente. Então, se puder, opte por aritmética de ponteiros também.

Este exame é relativamente tranquilo. O último exercício é de fato o mais difícil, mas o penúltimo, para mim, é o mais importante.

### Dicas

> *Domine a reversão de string com o método clássico de two pointers.*

> *Estude tanto índices quanto aritmética de ponteiros.*

## Exam01

Não venha para cá despreparado, já aviso logo. Sabe aqueles saltos de dificuldade que têm em alguns exercícios dos módulos em C? Então, aqui você vai encontrar algo parecido. É **fundamental**, antes de iniciar esse exame, saber:

- **Compilar** o arquivo corretamente.
- Trabalhar com **argumentos de CLI**.
- **Ponteiros, ponteiros, ponteiros!**
- A parte inicial de alocação de memória com `malloc` (para questões mais difíceis).

Ao contrário do último exame, para este aqui você não vai precisar dominar ou saber bem nenhum algoritmo clássico, mas **não se engane**! É necessário muita **lógica** e um nível maior de familiaridade com a **sintaxe C**, caso contrário, vai passar dificuldades. Quase todas as questões vão exigir que você saiba coletar os **parâmetros/argumentos de CLI** na hora de executar o programa - ele também vai pedir que você saiba **compilar corretamente** esse programa. Mas, sinceramente, essa parte não é tão complexa, e até o final do segundo terço da lista, a prova é **gostosa**, o nível de dificuldade é ascendente, mas relativamente linear, sem grandes pegadinhas.

Agora, mermão, as **últimas 3~4 questões**, especialmente a **última**, são complicadas. Sinceramente, eu não sei como eu reagiria tendo que resolver isso lá pessoalmente. Não sei como funciona a parte de consulta e o que você pode acessar durante a prova lá na escola, mas essas últimas questões **não são fáceis**.

Diferente do anterior, este eu **não consegui fazer numa sentada só**, foi parcelado, extrapolou e muito o que eu tinha pré-determinado como limite. Quando passou, eu meio que me permiti aproveitar e estudar mais, levando essas questões finais mais como uma **revisão** do que uma prova.

Particularmente, estou me permitindo usar **aritmética de ponteiros** e evitar ao máximo o uso de **índices**. Isso aumenta o nível de dificuldade para tirar as ideias do papel inicialmente, mas fico com a impressão de que o código fica mais **elegante**, **eficiente** e, por incrível que pareça, mais **fácil de ler e entender**.

